# from .map / .vmf / .blend / .bsp (VBSP):
new_vertices: List[Tuple[float, float, float]]  # x, y, z
new_indices: List[int]  # must be triangles
material_name: str  # must split geo by material


# to .bsp (rBSP)
bsp = bsp_tool.load_bsp(...)
r1 = bsp_tool.branches.respawn.titafall

vertex_index_offset = len(bsp.VERTICES)
bsp.VERTICES.extend(new_vertices)
mesh_index_offset = len(bsp.VERTEX_UNLIT)
special_vertices = [r1.VertexUnlit(position=vertex_index_offset + i, ...) for i, v in new_vertices]
bsp.VERTEX_UNLIT.extend(special_vertices)

mesh = r1.Mesh()
mesh.start_index = len(bsp.MESH_INDICES)
mesh.num_triangles = len(new_indices) // 3
mesh.unknown = (0,) * 8  # try copying if that doesn't work
mesh.material_sort = len(bsp.MATERIAL_SORT)
mesh.flags |= Flags.VERTEX_UNLIT
bsp.MESHES.append(mesh)

material_sort = r1.MaterialSort()
material_sort.texture_data = len(bsp.TEXTURE_DATA)
material_sort.lightmap_header = 0  # borrow some of the lightmap?
material_sort.cubemap = -1
material_sort.vertex_offset = 0
bsp.MATERIAL_SORT.append(material_sort)

texture_data = r1.TextureData()
texture_data.name_index = len(bsp.TEXTURE_DATA)
# size.width, size.height
# view.width, view.height
texture_data.flags = source.Surface.SKIP
bsp.TEXTURE_DATA.append(texture_data)

bsp.TEXTURE_DATA_STRING_DATA.apppend(material_name)

bsp.MESH_INDICES.extend([i + mesh_index_offset for i in mesh_indices])

# TODO: new model targeting the new mesh(es)
# TODO: func_brush using the model in bsp.ENTITIES

# not even complete but I think I know enough to put in some dummy values for the rest

# NOTE: trigger brushes are defined with "colN" keys in entities?
# -- looks like 64bit text encoded physics bytes?
